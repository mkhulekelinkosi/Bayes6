---
title: "bayesAssgnment 5"
output:
  word_document: default
  html_document: default
date: "2025-05-04"
---
# Data

```{r}
data<- readxl::read_xlsx("mydata.xlsx")
```
# 1.
## plot
```{r}
# Suppose your variable is in a column called "var"
library(dplyr)
g<-data.frame(data$Glucose)
df <-g  %>%
  mutate(
    censored = grepl("^<", data.Glucose),              # TRUE if value starts with <
    var_numeric = as.numeric(gsub("^<", "", data.Glucose))  # remove < and convert to numeric
  )
library(ggplot2)

ggplot(df, aes(x = var_numeric)) +
  geom_histogram(binwidth = 0.5, fill = "skyblue", alpha = 0.7, boundary = 0, closed = "left") +
  geom_rug(data = df %>% filter(censored), aes(x = var_numeric), color = "red") +
  labs(title = "Distribution of Variable with Censored Data",
       x = "Measurement (censored <3 shown in red)",
       y = "Count") +
  theme_minimal()

```


The data has column for Glucose which is made of non-fasting blood glucose measurements that is the amount of glucose in your blood after eating. The Glucose column has continuous data points but also includes values less than 3 as <3 and looking at the histogram the data is skewed to the right.

The data also has explanatory variables one of them as previous glucose level taken. which has same measure as scale as dependent variable. School and urban columns are categorical with missing values, and Age and BMI are continuous with missing values also.

# 2. Imputation.

```{r}
library(mice)
data_impute<- data[,c(-2,-3)]
data_impute$Urban <- as.factor(data_impute$Urban)
```
```{r, results='hide'}
imputed_data <- mice(data_impute, m=10, method="pmm", maxit=50, seed=500)
```

```{r}

completed_data_1 <- complete(imputed_data, 1) 
```

# 3.  Between imputation standard deviation.

```{r}

mean_vec <- numeric(10)

for (i in 1:10) {
  completed_data <- complete(imputed_data, i)
  mean_vec[i] <- mean(completed_data$BMI, na.rm = TRUE)
}
mu<- mean(mean_vec)
btw_std<- sqrt(var(mean_vec))
```

# 4.
# data

```{r}
completed_data_1 <- complete(imputed_data, 1) 
completed_data_1$Glucose <- data$Glucose
as.numeric(completed_data_1$Glucose[completed_data_1$Glucose == "<3"] <- 2.9)
N<- length(completed_data_1$Glucose)
```

 

# FIT

```{r}
stan_code <- "
data {
  int<lower=0> N;
  int<lower=1> K;
  matrix[N, K] X;
  vector[N] y;
}
parameters {
  vector[K] beta;
  real<lower=0> sigma;
}
model {
  target += -log(sigma);
  for (n in 1:N) {
    target += -log(2 * sigma) - fabs(y[n] - X[n] * beta) / sigma;
  }
}
"

```

```{r}
library(rstan)

X <- model.matrix(Glucose~ BMI + Age + Urban, data = completed_data_1)
y <-as.numeric(completed_data_1$Glucose)
data_list <- list(N = nrow(X), K = ncol(X), X = X, y = y)
```

```{r echo=FALSE, results='hide'}

fit <- stan(model_code = stan_code, data = data_list, 
            iter = 2000, chains = 4, seed = 123)

```
```{r}
print(fit)
```

# 5.

```{r}
stan<-"
  data {
  int<lower=0> N;                 
  int<lower=1> K;                 
  matrix[N, K] X;               
  vector[N] y;                    
  int<lower=0,upper=1> is_censored[N];  # 1 = censored, 0 = observed
}
parameters
{
  vector[K] beta;
  real<lower=0> sigma;
}

model
{
  target += -log(sigma); # // Prior on sigma: log π(σ) ∝ -log(σ)

  for (n in 1:N) {
    real mu = X[n] * beta;
    if (is_censored[n] == 1) {
      // Fully observed
      target += -log(2 * sigma) - fabs(y[n] - mu) / sigma;
    } else {
      // Left-censored: y[n] 
      target += log1m_exp(-fabs(y[n] - mu) / sigma);
    }
  }
}
"
```

```{r echo=TRUE, warning=FALSE}

censoring_point <- 3
is_censored <- ifelse(completed_data_1$Glucose < censoring_point, 1, 0)
y_observed <- pmin(completed_data_1$Glucose, censoring_point)

data_list1 <- list(
  N = length(y_observed),
  K = ncol(X),
  X = X,
  y = as.numeric(y_observed),
  is_censored = is_censored
)
```
```{r, results='hide'}
fit1 <- stan(model_code = stan, data = data_list1, 
            iter = 2000, chains = 4, seed = 123)
```
```{r}
print(fit1)
```


## probability  that each coefficient has changed by more than 2%.

```{r, warning=FALSE}

percent_change <- (as.matrix(fit1)- as.matrix(fit) / as.matrix(fit)) * 100
prob_gt_2 <- apply(abs(percent_change) > 2, 2, mean)
print(prob_gt_2)

```

# 6.
```{r, warning=FALSE}
completed_datasets <- lapply(1:10, function(i) complete(imputed_data, i))

completed_datasets <- lapply(completed_datasets, function(df) {
  df$Glucose <- completed_data_1$Glucose
  return(df)
})

results_list <- list()

for (i in 1:10) {
  df <- completed_datasets[[i]]


  X <- model.matrix(Glucose~ BMI + Age + Urban, data = df) 


  c_point <- 3
  is_censored <- ifelse(df$Glucose < c_point, 1, 0)
  y_obs <- ifelse(is_censored == 1, c_point, df$Glucose)

  data_list <- list(
    N = nrow(X),
    K = ncol(X),
    X = X,
    y = y_obs,
    is_censored = is_censored
  )


  fit <- stan(model_code = stan , data = list(
  N = length(y_observed),
  K = ncol(X),
  X = X,
  y = as.numeric(y_observed),
  is_censored = is_censored
),
              iter = 1000, chains = 2, seed = 123 + i,
              refresh = 0)

  # Store parameter simulations
  results_list[[i]] <- as.data.frame(rstan::extract(fit, pars = c("beta", "sigma")))
}




```

# 7.

```{r echo=TRUE, warning=FALSE}
all_draws <- do.call(rbind,  results_list)
library(tidyr)

library(dplyr)

summary_table <- all_draws %>%
    summarise(across(everything(), list(
    mean = ~mean(.),
    lower_95 = ~quantile(., 0.025),
    upper_95 = ~quantile(., 0.975)
  ))) %>%
  pivot_longer(cols = everything(),
               names_to = c("parameter", "stat"),
               names_sep = "_") %>%
  pivot_wider(names_from = stat, values_from = value)
print(summary_table)
```

# 8.

The estimate of beta 1 is the intercept and it is the median Glucose level when we have other explanatory variables equal to zero, meaning if we do not know the person BMI, Age and we just know is from the rural then that person will have Glucose level of 2.92. The person will observe 0.0014394765	increase in the blood glucose level if their BMI increases by a unit and from the rural, and also age has not changed, if a persons age increases by a unit then we expect the median Glucose to increase by 0.0003382594 and the BMI has not changed and the person is from the rural. if you are from the Urban the median Glucose level is 0.015133721 higher given your same age and have same BMI as the person from the rural.

# 8.

```{r}
data_2p<- data[c(13,14),]
```

Subject 1 is a 32 years old and his previous Glucose is the same as the current one this might mean the subject does not do follow ups this might be because of the missing value in urban column he might have done this tests at a place he does not stay at.
subject 2 is 61 with BMI missing it could be due to that they do not know it or it was not recorded by the data handler.

we going to increase both their ages with 3 years and also put subject 1 in rural and make subject 1 BMI 20.
```{r}
data_2p[1,"Urban"]<- "rural"
data_2p[c(1,2), "Age"]<- c(35,64)
data_2p[2,"BMI"]<- 20

```

## posterior predictive dist

```{r, warning=FALSE}
X_new <- model.matrix(~ BMI + Age + Urban, data = data_2p)

posterior <- rstan::extract(fit)
beta_draws <- posterior$beta
sigma_draws <- posterior$sigma
n_draws <- length(sigma_draws)


y_pred_sub1 <- numeric(n_draws)
y_pred_sub2 <- numeric(n_draws)

r_laplace <- function(mu, b) {
  u <- runif(length(mu), -0.5, 0.5)
  mu - b * sign(u) * log(1 - 2 * abs(u))
}
# Linear predictors for all draws (matrix multiplication)
mu_pred <- X_new %*% t(beta_draws)  # result: 2 x n_draws

# Generate predictions
sub1_pred <- r_laplace(mu = mu_pred[1, ], b = sigma_draws)
sub2_pred <- r_laplace(mu = mu_pred[2, ], b = sigma_draws)

pred_sub1=quantile(sub1_pred, c(0.025, 0.5, 0.975))
sub1<- pred_sub1["50%"]
pred_sub2=quantile(sub2_pred, c(0.025, 0.5, 0.975))
sub2<- pred_sub2["50%"]
print(sub1)
print(sub2)
```

The predictions given by the median seem to be good predictions especial1y for the subject 2 4.4 is not that for from observed Glucose and also not that far from previous observed glucose but given that this subject has been keeping in shape.
